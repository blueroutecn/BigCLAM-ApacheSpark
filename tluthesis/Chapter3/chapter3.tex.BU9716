\chapter{Ứng dụng mạng neural bài toán đự đoán bệnh tiểu đường loại 2}
\ifpdf
    \graphicspath{{Chapter3/Chapter3Figs/PNG/}{Chapter3/Chapter3Figs/PDF/}{Chapter3/Chapter3Figs/}}
\else
    \graphicspath{{Chapter3/Chapter3Figs/EPS/}{Chapter3/Chapter3Figs/}}
\fi
\section{Sơ lược bài toán}
Bệnh tiểu đường trong thời đại hiện nay là một trong những căn bệnh phổ biến nhất. Ở một số nước, số người mắc căn bệnh này chiếm tỉ lệ tới 10\% dân và số người mắc bệnh này ngày tăng cao. Phần lớn bệnh nhân mắc chứng tiểu đường loại 2 và tỉ lệ người bệnh tăng cao liên quan trực tiếp với cách sống của cuộc sống hiện đại ngày nay.

Vào khoảng giữa những năm 80 của thế kỷ trước, tổng số người mắc bệnh tiểu đường trên thế giới vào khoảng 30 triệu. Ngày nay con số đó lên tới 246 triệu dự đoán tới năm 2025 số người mắc sẽ lên tới 380 triệu. Căn bệnh này làm ảnh hưởng lớn tới nền kinh tế thế giới. Ước tính, mỗi năm thế giới phải bỏ ra 215 đển 375 tỷ đô la để chữa căn bệnh này.

Nguyên nhân chính dẫn tới sự bùng nổ của căn bệnh này là do cách sống thời hiện đại ngày nay: đó là cuộc sống ít hoạt động theo cách công sở và chế độ ăn uống không phù hợp. Ngày nay, các bác sĩ đã biết được nguyên nhân gây bênh cũng như quá trình phát triển bệnh nên khả năng chữa trị cũng tăng cao. Có hai nguyên nhân gây tăng đường máu và theo đó người ta chia bệnh tiểu đường ra làm hai loại chính: Tiểu đường loại 1 và tiểu đường loại 2:
\begin{itemize}
	\item \textbf{Tiểu đường loại 1:} tuyến tụy của bệnh nhân hầu như hoặc không có khả năng sản sinh ra insulin - một loại hóc môn nhằm giúp chuyên hóa đường trong máu thành năng lượng trong các tế bào. Ngyên nhân là do hệ miễn dịch tự hủy hoại các tế bào beta trong tuyến tụy có nhiệm vụ sản sinh ra insulin.
	\item \textbf{Tiểu đường loại 2:} lượng insulin được sản sinh ra ban đầu hoàn toàn bình thường, nhưng các tế bào đã không hoặc kém nhậy cảm với sự có mặt của insulin. Đó là hiện tượng nhờn insulin (kháng insulin). Lượng đường trong máu do không được chuyển hóa thành năng lượng nên giữ ở mức cao, cơ thể bệnh nhân phản ứng bằng cách tăng sản xuất insulin lên, gây nên quá tải cho tuyến tụy và lượng insulin được tiết ra dần dần giảm.
\end{itemize}
Tiểu đường loại 2 có nguyên nhân tiềm ẩn trong cấu tạo gen. Nếu những người mắc loại này nếu không sống và ăn uống khoa học, căn bệnh này sẽ phát triển rất nhanh.

Theo báo cáo: Những người thuộc bộ tốc da đỏ Pima Indians. Các bác sĩ phát hiện ra rằng ở những người da đỏ này có gen tiềm ẩn bênh tiểu đường loại 2. Hiện nay người Pima này sống ở hai vùng khác biệt. Nhóm phía nam sống ở Mexicô, họ vẫn giữ tập tục cổ xưa. Họ phải hoạt động rất nhiều để thu hái được lượng thức ăn hiếm hoi trên sa mạc. Họ sống bằng nghề nông và đánh bắt vất vả. Nhóm phía bắc sống ở Mỹ thuộc bang Arizona. Nhóm này sống đúng theo phong cách hiện đại: họ đi làm bằng oto, mua đồ trong siêu thị, hoạt động ít, ăn uống quá đầy đủ. Nhìn vào hai bộ tộc này mới thấy được phong cách sống ảnh hưởng tới sức khỏe của con người như thế nào. Trong khi những người thuộc nhóm phía nam có vóc dáng nhỏ nhắn, khỏe mạnh, còn những người phía bắc giữ kỷ lục về bệnh béo phì và tiểu đường.

Trong báo cáo này, ta chọn tập dữ liệu về tiểu đường của bộ tốc da đỏ Pima Indians để thực hiện bài toán dự đoán bênh tiểu đường loại 2. Tập dữ liệu này được trường Đại học California thực hiện lấy mẫu\footnote{\url{http://archive.ics.uci.edu/ml/datasets/Pima+Indians+Diabetes}}
\section{Mô tả tập dữ liệu}
Tập dữ liệu Pima Indians Diabetes - bệnh tiểu đường ở người phụ nữ da đỏ Pima Indians trên 21 tuổi, bộ dữ liệu gồm 8 biểu hiện và 1 lớp. Dữ liệu có cấu trúc như sau:
\begin{itemize}
	\item Mỗi dóng là thông tin về bệnh nhân, cuối mỗi dòng có dấu kết thúc là dấu ".";
	\item Trên mỗi dòng một bệnh nhân được thể hiện qua 9 biểu hiện, giữa 2 biểu hiện có dấu "," ngăn cách;
	\item Thuộc tính thứ 9 là biểu hiện kết quả biểu diễn cho hai giá trị $\{0,1\}$ tương ứng với không bị tiểu đường và bị tiểu đường;
	\item các biểu hiện tương ứng với một số đại lượng mà các bác sĩ dùng để xác định tình trạng bênh của bệnh nhân:
	\begin{enumerate}
		\item \textbf{Pregnancies}: Number of times pregnant -  Số lần mang thai của người phụ nữ.
		\item \textbf{Glucose}: Plasma glucose concentration a 2 hours in an oral glucose tolerance test - Nồng độ glucose tương huyết sau 2 giờ trong liệu pháp tăng glucose máu bằng đường uống;
		\item \textbf{BloodPressure}: Diastolic blood pressure (mm Hg) - Huyết áp tâm trương;
		\item \textbf{SkinThickness}: Triceps skin fold thickness (mm) - Đo lượng mỡ dưới da bằng cách gấp cơ tam đầu;
		\item \textbf{Insulin}: 2-Hour serum insulin (mu U/ml) - insulin huyết thanh sau 2 giờ;
		\item \textbf{BMI}: Body mass index $(weight in kg/(height in m)^2) $ - Chỉ số cơ thể BMI
		\item \textbf{DiabetesPedigreeFunction}: Diabetes pedigree function - chỉ số di truyền của bệnh tiểu đường;
		\item \textbf{Age}: Age (years) - Tuổi của bệnh nhân;
		\item \textbf{Outcome}: Class variable (0 or 1) - 0: không bị tiểu đường; 1: bị tiểu đường.
	\end{enumerate}
\end{itemize}

Tập dữ liệu ta sử dụng có cỡ mẫu là $768$ quan sát. Dưới đây là thể hiện 30 quan sát đầu tiên của dữ liệu. \\

Pregnancies Glucose BloodPressure SkinThickness	Insulin BMI DiabetesPedigreeFunction Age \textbf{Outcome}
\begin{lstlisting}
	6	148	72	35	0	33.6	0.627	50	1
	1	85	66	29	0	26.6	0.351	31	0
	8	183	64	0	0	23.3	0.672	32	1
	1	89	66	23	94	28.1	0.167	21	0
	0	137	40	35	168	43.1	2.288	33	1
	5	116	74	0	0	25.6	0.201	30	0
	3	78	50	32	88	31	0.248	26	1
	10	115	0	0	0	35.3	0.134	29	0
	2	197	70	45	543	30.5	0.158	53	1
	8	125	96	0	0	0	0.232	54	1
	4	110	92	0	0	37.6	0.191	30	0
	10	168	74	0	0	38	0.537	34	1
	10	139	80	0	0	27.1	1.441	57	0
	1	189	60	23	846	30.1	0.398	59	1
	5	166	72	19	175	25.8	0.587	51	1
	7	100	0	0	0	30	0.484	32	1
	0	118	84	47	230	45.8	0.551	31	1
	7	107	74	0	0	29.6	0.254	31	1
	1	103	30	38	83	43.3	0.183	33	0
	1	115	70	30	96	34.6	0.529	32	1
	3	126	88	41	235	39.3	0.704	27	0
	8	99	84	0	0	35.4	0.388	50	0
	7	196	90	0	0	39.8	0.451	41	1
	9	119	80	35	0	29	0.263	29	1
	11	143	94	33	146	36.6	0.254	51	1
	10	125	70	26	115	31.1	0.205	41	1
	7	147	76	0	0	39.4	0.257	43	1
	1	97	66	15	140	23.2	0.487	22	0	
\end{lstlisting}
Bài toán đặt ra lá phải chuẩn đoán được dấu hiệu của bệnh tiểu đường loại 2 ở phụ nữ thông qua tập dữ liệu mẫu của những người phụ nữ da đỏ Pima trên $21$ tuổi có gen tiềm ẩn bệnh tiểu đường loại hai.

\section{Mô hình bài toán}

Phần này, ta sẽ đi vào xây dựng mô hình bài toán chẩn đoán bệnh tiểu đường loại hai gồm các bước được thể hiện qua Hình ~\ref{fig:Mohinhbaitoan}:
\begin{enumerate}
	\item Tóm tắt dữ liệu 
	\item Làm sạch và tiền xử lý dữ liệu
	\item Phân chia dữ liệu huấn luyện và dữ liệu test
	\item Lựa chọn và triển khai mô hình huấn luyện
	\item Đánh giá độ tin cậy, chính xác của mô hình.
\end{enumerate}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=1\linewidth]{ThesisFigs/MLProccess.png}
	\end{center}
	\caption{Quy trình thực hiện}
	\label{fig:Mohinhbaitoan}
\end{figure}

\subsection{Tóm tắt dữ liệu}
Khi đã thu thập dữ liệu, một nhu cầu tất yêu là ta cần phải có cái nhìn tổng quát về dữ liệu bằng cách tóm tắt lại dữ liệu để xem cấu trúc của dữ liệu gồm các thành phần như thế nào, những biểu hiện nào là chủ yếu, biểu hiện nào là hiếm, biểu hiện nào là cần thiết cho bài toán,\dots Một trong những tính chất của dữ liệu ta cần quan tâm là xu hướng tập trung và phân tán của dữ liệu. Sự tập trung của dữ liệu có thể đo được bằng các đại lượng thống kê như: solượng tổng thể (count), giá trị trung bình(mean),\dots. Độ phân tán của dữ liệu đo được bằng các số đo: mức độ đồng đều (std), tứ phân vị (min, $25\%$, $50\%$,$75\%$,max),\dots
 Với đoạn mã dưới đây được thực hiện bằng python sử dụng thư viện pandas cho ta thấy được các đại lượng thông kê của từng biểu hiện.
\begin{lstlisting}[language=python]
import pandas as pd
data=pd.read_csv('project/PIDs.csv')
data.describe()

       Pregnancies     Glucose  BloodPressure  SkinThickness     Insulin  \
       count   768.000000  768.000000     768.000000     768.000000  768.000000   
       mean      3.845052  120.894531      69.105469      20.536458   79.799479   
       std       3.369578   31.972618      19.355807      15.952218  115.244002   
       min       0.000000    0.000000       0.000000       0.000000    0.000000   
       25%       1.000000   99.000000      62.000000       0.000000    0.000000   
       50%       3.000000  117.000000      72.000000      23.000000   30.500000   
       75%       6.000000  140.250000      80.000000      32.000000  127.250000   
       max      17.000000  199.000000     122.000000      99.000000  846.000000   
       
       BMI  DiabetesPedigreeFunction         Age     Outcome  
       count  768.000000                768.000000  768.000000  768.000000  
       mean    31.992578                  0.471876   33.240885    0.348958  
       std      7.884160                  0.331329   11.760232    0.476951  
       min      0.000000                  0.078000   21.000000    0.000000  
       25%     27.300000                  0.243750   24.000000    0.000000  
       50%     32.000000                  0.372500   29.000000    0.000000  
       75%     36.600000                  0.626250   41.000000    1.000000  
       max     67.100000                  2.420000   81.000000    1.000000  
\end{lstlisting}

Nhìn vào các đại lượng trên của các biểu hiện cho thấy được mức độ đồng đều của các biểu hiện khá xa nhau đồng thời dựa vào ý nghĩa của các biểu hiện thấy rằng có rất nhiều giá trị bị thiếu (chính là các giá trị $0$). Do vậy ta cần phải thực hiện xứ lý các vấn đề trên thông qua hai phương pháp: Điều chỉnh miền dữ liệu (Data Scaling) và dữ liệu bị thiếu(Data has missing values). Hai phương pháp này sẽ được thực hiện ở phần tiếp theo.

\subsection{Làm sạch và tiền xử lý dữ liệu}
Trong quá trình huấn luyện bài toán nói riêng hay trong khai phá dữ liệu nói chúng, việc hiểu được biểu hiện của dữ liệu giúp cho quá trình phân tích dữ liệu trở lên hiệu quả hơn rất nhiều. Trong quá trình hiểu dữ liệu trên thực tế, khả năng có thể dữ liệu bị nhiễu, không đầy đủ và không nhất quán. Vì vậy mà ta cần có bước làm sạch và tiền xử lý dữ liệu nhằm đảm bảo dữ liệu đầu vào cho mô hình học là chuẩn và chính xác, vì chất lượng của dữ liệu có ảnh hưởng rất lớn đến kết quả của mô hình đầu ra. 

\subsubsection{Điều chỉnh miền dữ dữ liệu}
Điều chỉnh miền dữ liệu - Feature Scaling là một phương pháp được sử dụng để quy chuẩn phạm vi miền của dữ liệu. Vì phạm vi của miền dữ liệu của các biểu hiện có thể khác nhau làm ảnh hưởng cho một số thuật toán học máy trở lên giảm hiệu năng như thời gian chạy quá lâu, tiêu tốn tài nguyên,\dots

Phương pháp thực hiện feature scaling thường được dùng phổ biến trong các thuật toán học như SVM, Neural Network,\dots
\begin{eqnarray}
	x\prime = \dfrac{x-\bar{x}}{\sigma}
\end{eqnarray}
Trong đó: $\bar{x}$ là trung bình tổng thể, $\sigma$ là độ lệch chuẩn của tổng thể.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.7\linewidth]{ThesisFigs/FeatureScaling.png}
	\end{center}
	\caption{So sách hiệu năng hiệu năng huấn luyện khi dùng không dùng (trái) và dùng phương pháp Feature Scaling}
	\label{fig:Fs}
\end{figure}

Nhìn vào hinh~\ref{fig:Fs}, ta có thể thấy rằng chi phí thực hiện của các thuật toán học để đi từ một điểm bất kỳ đến điểm có giá trị cực tiểu $J(\theta)\sim 0$ của hình bên trái vòng vèo với hình bên phải thì ngược lại khi áp dùng phương pháp Feature Scaling.

Đối với dữ liệu trên, nhìn vào các đại lượng thống kê như std, tứ phân vị,\dots trong phần tóm tắt dữ liệu sự phân phối của dữ liệu không đồng đều. Như vậy ta cần thực hiện phương pháp Feature scaling như sau:

\begin{lstlisting}[language=python]
xpre=(data.loc[:,'Pregnancies'] - data.loc[:,'Pregnancies'].mean())
xpre=xpre/(data.loc[:,'Pregnancies'].std())
data.loc[:,'Pregnancies']=xpre

xglc=(data.loc[:,'Glucose'] - data.loc[:,'Glucose'].mean())
xglc=xglc/(data.loc[:,'Glucose'].std())
data.loc[:,'Glucose']=xglc

xbl=(data.loc[:,'BloodPressure'] - data.loc[:,'BloodPressure'].mean())
xbl=xbl/(data.loc[:,'BloodPressure'].std())
data.loc[:,'BloodPressure']=xbl

xst = (data.loc[:,'SkinThickness'] - data.loc[:,'SkinThickness'].mean())
xst = xst /(data.loc[:,'SkinThickness'].std())
data.loc[:,'SkinThickness']=xst

xins=(data.loc[:,'Insulin'] - data.loc[:,'Insulin'].mean())
xins=xins/(data.loc[:,'Insulin'].std())
data.loc[:,'Insulin']=xins


data.loc[:,'BMI']=(data.loc[:,'BMI'] - data.loc[:,'BMI'].mean())/(data.loc[:,'BMI'].std())

xdpf=(data.loc[:,'DiabetesPedigreeFunction'] - data.loc[:,'DiabetesPedigreeFunction'].mean())
xdpf=xdpf/(data.loc[:,'DiabetesPedigreeFunction'].std())
data.loc[:,'DiabetesPedigreeFunction']=xdpf

data.loc[:,'Age']=(data.loc[:,'Age'] - data.loc[:,'Age'].mean())/(data.loc[:,'Age'].std())
	
\end{lstlisting}

\subsubsection{Xử lý dữ liệu bị thiếu}
Giá trị bị thiếu có thể hiểu là một số dữ liệu nào đó trong bảng số liệu bị lỗi. Lỗi này có thể là không có thông tin, thông tin sai hoặc thông tin không hợp logic. Trong tập dữ liệu trên ta chỉ xét dến lỗi dữ liệu không có thông tin. Điều này chính là nguyên nhân gây ra giảm đi tính thuyết phục, tính chính xác của dữ liệu. Điều đó làm ảnh hưởng đến chất lượng của mô hình.

Để xử lý các dữ liệu bị thiếu thường có $2$ cách như sau:
\begin{itemize}
	\item Tiền hành loại bỏ các quan sát ứng với các giá trị thiếu. Vì vậy, phần còn lại trong dữ liệu là đầy đủ dữ liệu cho tất cả các quan sát. Nhược điểm của cách này là làm giảm kích thước mẫu dữ cỡ mẫu dữ liệu.
	\item Thực hiện thay thế các giá trị thiếu. Thông thường các giá trị được thay thế được chọn là giá trị trung bình, trung vị, mode, ước lượng khoảng,... của tổng thể.
\end{itemize}

Với tập dữ liệu của ta, do cơ mẫu không quá lớn nên ta sẽ chọn cách 2 (Thay thế giá trị bị thiếu bằng giá trị trung bình của tổng thể). Dựa vào ý nghĩa của từng biểu hiện ta thấy được các biểu hiện Glucose, BloodPressure, BMI, Insulin, SkinThickness không thể có giá trị bằng $0$ tức là những giá trị đó cần phải thay thế. Việc thay thế được thể hiện qua đoạn mã sau:

\begin{lstlisting}[language=python]
	glc=data.loc[data['Glucose']!=0,'Glucose']
	data.loc[data['Glucose']==0,'Glucose']=sum(glc)/(len(glc)*1.0)
	
	bp=data.loc[data['BloodPressure']!=0,'BloodPressure']
	data.loc[data['BloodPressure']==0,'BloodPressure']=sum(bp)/(len(bp)*1.0)
	
	bmi=data.loc[data['BMI']!=0,'BMI']
	data.loc[data['BMI']==0,'BMI']=sum(bmi)/(len(bmi)*1.0)
	
	st=data.loc[data['SkinThickness']!=0,'SkinThickness']
	data.loc[data['SkinThickness']==0,'SkinThickness']=sum(st)/(len(st)*1.0)
	
	Ins=data.loc[data['Insulin']!=0,'Insulin']
	data.loc[data['Insulin']==0,'Insulin']=sum(Ins)/(len(Ins)*1.0)
\end{lstlisting}
\subsection{Phân chia dữ liệu huấn luyện và dữ liệu test}
Ta phân chia tập dữ liệu trên thành hai phần là $X$ là tập các biểu hiện và $Y$ là tập kết quả. Tiếp tục chia các quan sát thành hai phần training ($70\%$) và testing ($30\%$). Nhằm tách biệt dữ liệu dùng để huấn luyện và dữ liệu để đánh giá mô hình, tránh bị trình trạng overfitting quá khít với dữ liệu mẫu mà không dự đoán tốt với dữ liệu mới. Dưới đây là đoạn mã được thực hiện trên python:

\begin{lstlisting}[language=python]
from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import train_test_split
import numpy

# fix random seed for reproducibility
seed = 7
numpy.random.seed(seed)

# convert pandas into numpy
clm_list = []
for column in data.columns:
clm_list.append(column)

X = data[clm_list[0:len(clm_list)-1]].values
y = data[clm_list[len(clm_list)-1]].values

# split into 70% for train and 30% for test
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.3,
 random_state=seed)
\end{lstlisting}

Và sau khi làm sách ta có thể thấy sự thay đổi của các đại lượng thống kê của từng biểu hiện như sau:
\begin{lstlisting}[language=python]
 Pregnancies       Glucose  BloodPressure  SkinThickness       Insulin  \
 count  7.680000e+02  7.680000e+02   7.680000e+02   7.680000e+02  7.680000e+02   
 mean  -7.864080e-17 -3.492577e-16   6.869505e-16   7.956598e-16 -4.972874e-17   
 std    1.000000e+00  1.000000e+00   1.000000e+00   1.000000e+00  1.000000e+00   
 min   -1.141108e+00 -2.552467e+00  -4.001637e+00  -2.520028e+00 -6.924393e-01   
 25%   -8.443348e-01 -7.207517e-01  -6.948531e-01  -4.724658e-01 -6.924393e-01   
 50%   -2.507887e-01 -1.539877e-01  -1.674821e-02   8.082669e-16 -4.277835e-01   
 75%    6.395305e-01  6.099116e-01   6.278603e-01   3.238084e-01  4.117396e-01   
 max    3.904034e+00  2.540195e+00   4.099983e+00   7.945290e+00  6.648507e+00   
 
 BMI  DiabetesPedigreeFunction           Age     Outcome  
 count  7.680000e+02              7.680000e+02  7.680000e+02  768.000000  
 mean   3.145632e-16              2.451743e-16  2.035409e-16    0.348958  
 std    1.000000e+00              1.000000e+00  1.000000e+00    0.476951  
 min   -2.073767e+00             -1.188778e+00 -1.040871e+00    0.000000  
 25%   -7.210698e-01             -6.885198e-01 -7.857741e-01    0.000000  
 50%   -8.358168e-03             -2.999328e-01 -3.606124e-01    0.000000  
 75%    6.025375e-01              4.659233e-01  6.597757e-01    1.000000  
 max    5.038803e+00              5.879733e+00  4.061069e+00    1.000000 
\end{lstlisting}
\subsection{Lựa chọn mô hình và thực hiện huấn luyện}
Trong báo cáo này trình bày mô hình mạng neural nhiều tầng truyền thằng và giải thuật lan truyền ngược. Trong phần này, ta sẽ áp dụng mô hình này và giải thuật lan truyền ngược vào bài toán.

Dưới đây là mã nguồn xây dựng một mô hình mạng neural nhân tạo các tầng kết nối đầy đủ với $1$ tầng tín hiệu đầu vào gồm $8$ đơn vị neural, $1$ tầng tín hiệu đầu ra với $1$ đơn vị neural đầu ra, $2$ tầng ẩn lần lượt là $12$ và $8$ đơn vị neural. Hai tầng ẩn ta sử dụng hàm kích hoạt ReLU do độ dốc liên tục của ReLUs hiệu quả trong việc học nhanh hơn ở tầng ẩn. Và sử dụng hàm sigmoid ở tầng output để quyết định giá trị 0- không bị; 1 - bị bệnh tiểu đường loại hai.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=1\linewidth]{ThesisFigs/sigmoidvsrelu.png}
	\end{center}
	\caption{Biểu đồ thể hiện cho hàm kích hoạt Sigmoid (trái) và Relus (phải)}
	\label{fig:sigmoidvsrelu}
\end{figure}

Ta triển khai huấn luyện mạng trên giải thuật lan truyền ngược và garden descent.

Môi trường thực hiên trong báo cáo này, được triển khai trên \href{https://www.python.org/}{Python 2.7} sử dụng các thư viện \href{http://scipy.org/}{SciPy}, \href{https://keras.io/}{Keras}, \href{http://scikit-learn.org/}{scikit-learn} và \href{http://deeplearning.net/software/theano/}{Theano} + \href{https://www.tensorflow.org/}{TensorFlow}. Sử dụng thuật toán gradient descent và giả thuật lan truyển ngược trong quá trình huấn luyện mạng.

\begin{lstlisting}[language=python]
model = Sequential()
model.add(Dense(12, input_dim=8, init='uniform', activation='relu'))
model.add(Dense(8, init='uniform', activation='relu'))
model.add(Dense(1, init='uniform', activation='sigmoid'))

# Compile model with 
model.compile(loss='mse', optimizer='sgd',metrics=['accuracy'])

\end{lstlisting}
\subsection{Đánh giá mô hình}
Việc đánh giá mô hình để đánh giá kết quả của quá trình huấn luyện (tiền xử lý dữ liệu, chọn thuật toán học, phướng pháp tối ưu,\dots) có tốt hay không? Trên thực tế, ta cần áp dụng nhiều thuật toán học để chọn một mô hình phù hợp nhất cho bài toán thông qua việc đánh giá mô hình.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.7\linewidth]{ThesisFigs/k-fold-cross-validation.png}
	\end{center}
	\caption{k-fold Crosss validation}
	\label{fig:k-flodcv}
\end{figure}

Ở đấy ta sử dụng phướng pháp đánh giá Cross Validation hay còn gọi là k-fold Cross validation. Phương pháp này phân chia dữ liệu thành $k$ tập con có cùng kích thước. Tại mỗi vòng lặp sử dụng một tập con là tập thử nghiệm và các tập con còn lại là tập huấn luyện. Giá trị $k$ thường là $10$

\begin{lstlisting}
	model.fit(X_train, y_train, validation_data=(X_test,y_test), nb_epoch=150,
	batch_size=10)
	loss, accuracy = model.evaluate(X, Y)
\end{lstlisting}

Kết quả thu được qua quá trình đánh giá mô hình với với phương pháp cross-validation thi được độ chính xác:
\begin{lstlisting}
acc: 75.64%
\end{lstlisting}
